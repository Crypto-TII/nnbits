#--- DATA INFORMATION
# The data should be contained in a single *.npy file stored in `datapath`.
# Note: When loaded by using `data=np.load(datapath)`, the `data.shape` is expected to be
# (number of sequences, number of bits per sequence).
datapath = '/opt/cryptanalysis_servers_shared_folder/NBEATSCipherDistinguisher/D5/speck_32_64/round6_sequences200k_.npy'
# The number of bits per sequence is 32**2 = 1024 for Speck 32; 128**2=16384 for Speck 128. It is stored in `N_BITS`:
N_BITS = 1024
# How many sequences to use for training
# (the batch size is set to 4096, so please choose a multiple of 4096):
N_TRAIN = 81920
# How many sequences to use for validation:
N_VAL = 102400
#------------------------------

#--- HARDWARE INFORMATION
# How many GPUs will be used:
N_GPUS = 4
# Each GPU will host a certain number of actors.
# Note: This number will depend on the model and data complexity.
# We have used N_ACTORS_PER_GPU = 3 for Speck 32 and N_ACTORS_PER_GPU=2 for Speck 128.
N_ACTORS_PER_GPU = 3
# GPU fraction per actor (typically 0.33 for Speck 32 and 0.5 for Speck 128 for GPUs with 40GB memory per GPU):
NUM_GPUS=0.33
# CPUs per actor (typically 8 for Speck 32 and 28 for Speck 128 if you have 128 CPU cores available):
NUM_CPUS=8
#------------------------------

#--- TRAINING INFORMATION
# The `MODEL_ID` identifies which model is to be used:
# 'nbeats'
# 'gohr'
# 'nbeats_and_conv'
MODEL_ID = 'gohr_generalized'
# Some models like N_BEATS and MLP can be scaled to a higher representational power.
# Speck 32: 1; Speck 128: 4
MODEL_STRENGTH = 1
# For how many epochs should the model be trained?
N_EPOCHS = 10
# Various randomly selected combinations of inputs and output bits will be tried out.
# How many combinations are tried is given by the number of filters `N_FILTERS`.
# This can be a list: If various input lengths are to be tried out, the list of `N_INPUTS` needs to have identical length.
# (Typically for Speck 32 choose 24 filters and for Speck 128 choose 12 filters):
N_FILTERS = [24, 24, 24, 24]
# (Typically for Speck 32 choose 28**2, 29**2, 30**2, 31**2 = [784, 841, 900, 961] as N_INPUTS)
# For Speck 128 120**2, 122**2, 124**2, 126**2 = [14400, 14884, 15376, 15876]
N_INPUTS = [961, 961, 961, 961] #[784, 841, 900, 961]
# For the creation of filters, three different strategies can be chosen
# 'random': choose the predicted bits at random, however, across `N_FILTERS`
#           we try to assure that each bit is chosen the approximate same number of times
# 'weak': after information on all bits becomes available, it may be interesting to choose the bits farest away from 50% accuracy.
#           This is done in the 'weak' predicted bit strategy.
# 'target': if the strategy is targetted, a list of target bits corresponding to N_FILTERS has to be provided.
# 'gohr_with_target': The target bit will be zero-ed out and the predicted bit is the last one in the dataset.
#            Use this filter strategy together with a DATA_STRATEGY='zero_gohr' and N_INPUTS=64 and N_BITS=65.
FILTER_STRATEGY = ['random','random','random','random']#['random', 'weak', 'weak', 'weak']
TARGET_BITS = []
# The bits which are to be predicted have to be removed from the input in some way.
# 'remove': In this strategy the bits will actually be removed from the input data.
# 'zero': In this strategy the bits will only be zero-ed at the input to remove their information. This will preserve the data shape.
# 'zero_gohr': The target bit will be zero-ed out and the predicted bit is the last one in the dataset provided.
#            Use together with filter strategy 'gohr_with_target'.
DATA_STRATEGY = 'remove'
#------------------------------